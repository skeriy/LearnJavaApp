{
  "theme": {
    "1": {
      "name": "Основные понятия",
      "sub_theme": {
        "1": {
          "id": "1",
          "name": "Введение в Java",
          "theory": {
            "1": {
              "name": "Добро пожаловать в Java",
              "text": "Java это современный язык программирования высокого уровня, разработанный в первой половине 1990-х компанией Sun Microsystems, в последующем приобретённой компанией Oracle.\n\nJava является Платформо-Независимым языком программирования, что значит, что вам необходимо написать программу один раз, чтобы запустить ее на множестве различных платформ!\n\nJava является переносимым, строго типизированным, и динамическим языком программирования, с возможностью соответствия потребностям практически любого типа приложения.\nJava гарантирует, что вы можете написать программу один раз, и запускать ее на любых платформах.\n\nЯзык программирования Java используется для разработки приложений под Google Android OS, различных Настольных Приложений, например медиа-плееров, антивирусных программ, Веб Приложений, Корпоративных Приложений (например в банковской сфере), и многое другое!"
            }
          },
          "practice": {
            "1": {
              "type": "r_task",
              "text": "Чтобы выпустить вашу программу на различные платформы, какое количество версий вам необходимо создать?",
              "questions": [
                "Только одну версию",
                "Две версии",
                "программы на Java можно писать только на одну платформу",
                "По одной на каждую платформу"
              ],
              "succes": ["Только одну версию"]
            }
          }
        },
        "2": {
          "id": "2",
          "name": "Ваша первая программа на Java",
          "theory": {
            "1": {
              "name": "Первая программа на Java",
              "text": "Давайте начнем с создания простой программы, которая выводит на экран текст \"Hello World\".\n\nclass MyClass {\n  public static void main(String[ ] args) {\n   System.out.println(\"Hello World\");\n}\n}\n\nВ Java, каждая строка кода, которая может быть запущена, должна быть внутри класса.\nВ нашем примере, мы назвали класс MyClass. Вы узнаете больше о классах в последующих модулях.\n\nВ Java, каждое приложение имеет точку входа, или точку старта, которая является методом с именем main. Метод main и ключевые слова public и static будут разъяснены позже."
            },
            "2": {
              "name": "Метод main",
              "text": "Для запуска нашей программы, метод main должен быть идентичен следующей записи:\n\npublic static void main(String[ ] args)\n\n- public: любой может получить к нему доступ\n- static: метод может быть запущен без создания экземпляра класса, содержащего метод main\n- void: метод не возвращает значение\n- main: имя метода\n\nНапример, следующий код объявляет метод test, который не возвращает ничего и не имеет параметров:\n\nvoid test()\n\nПараметры методов объявляются внутри скобок, которые следуют после имени метода.\nДля main, это массив строк, который называется args. Мы будем использовать его в следующем уроке, так что не волнуйтесь, если вы не все понимаете сейчас."
            },
            "3": {
              "name": "System.out.println()",
              "text": "Рассмотри тело метода main, заключенное в фигурные скобки:\n{\n  System.out.println(\"Hello World!\");\n}\nМетод println выводит строку текста на экран.\nКласс System и его поток out используются для получения доступа к методу println.\nВ классах, методах, и других структурах код всегда заключается в фигурные скобки { }."
            },
            "4": {
              "name": "Точки с запятыми в Java",
              "text": "Вы можете передать различный текст в качестве параметра в метод println для его вывода.\n\nclass MyClass {\n public static void main(String[ ] args) {\n   System.out.println(\"I am learning Java\");\n }\n}\nВ Java, каждое выражение должно заканчиваться точкой с запятой.\nПомните: не используйте точки с запятыми после объявлений методов и классов, после которых следует определение тела с помощью фигурных скобок."
            }
          },
          "practice": {
            "1": {
              "type": "r_task",
              "text": "Какой метод является точкой старта для всех Java программ?",
              "questions": [
                "run",
                "main",
                "go",
                "start"
              ],
              "succes": ["main"]
            },
            "2": {
              "type": "it_task",
              "text": "Заполните пустые поля, чтобы объявить метод с именем \"hello()\"",
              "rows": [
                ["void ", "()"]
              ],
              "paste": [
                1
              ],
              "succes": [
                "hello"
              ]
            },
            "3": {
              "type": "r_task",
              "text": "Какой метод выводит текст в Java программах?",
              "questions": [
                "System.out.writeText()",
                "System.out()",
                "System.out.printText()",
                "System.out.println()"
              ],
              "succes": ["System.out.println()"]
            },
            "4": {
              "type": "it_task",
              "text": "Заполните пустые места, чтобы создать рабочую Java программу",
              "rows": [
                ["", " Hello {"],
                ["    public static void ","(String[] args) {"],
                ["        System.out.println(\"Hello world!\")"],
                ["    }"],
                ["}"]
              ],
              "paste": [
                1,2
              ],
              "succes": [
                "class",
                "main"
              ]
            }
          }
        },
        "3": {
          "id": "3",
          "name": "Комментарии в Java",
          "theory": {
            "1": {
              "name": "Комментарии",
              "text": "Целью включения комментариев в ваш код является объяснение, что делает ваша программа.\nJava поддерживает и однострочные, и многострочные комментарии. Все символы, которые находятся внутри комментариев, игнорируются Java компилятором.\n\nОднострочный комментарий начинается с двух косых черт (слэшей) и продолжается до окончания строки.\n\nНапример:\n// однострочный комментарий\nx = 5; // однострочный комментарий после кода"
            },
            "2": {
              "name": "Многострочные комметарии",
              "text": "Java также поддерживает комментарии, которые занимают несколько строк. Такой комментарий начинается с символа косой черты, за которым следует символ звездочки, и заканчивается символом звездочки, за которым следует символ косой черты.\n\nНапример:\n/* This is also a\ncomment spanning\nmultiple lines */\n\nОбратите внимание, что Java не поддерживает вложенные многострочные комментарии.\nОднако, вы можете вложить однострочные комментарии внутри многострочных комментариев.\n\n/* This is a single-line comment:\n\n// a single-line comment\n\n*/\n\nДругим названием многострочного комментария является блочный комментарий."
            },
            "3": {
              "name": "Комментарии документации",
              "text": "Комментарии документации это специальные комментарии, которые выглядят как многострочные комментарии, но отличаются тем, что они генерируют внешнюю документацию вашего исходного кода. Они начинаются с символа косой черты, за которым следует два символа звездочки, и заканчивается символом звездочки, за которым следует символ косой черты.\n\nНапример:\n/** This is a documentation comment */\n\n/** This is also a\ndocumentation comment */\n\nJavadoc это инструмент, который включен в JDK и используется для генерации документации Java кода в HTML формате из исходного Java кода, которому необходима документация в предопределенном формате.\n\nЕсли комментарий документации начинается более чем с двух символов звездочки, то Javadoc предполагает, что вы хотели создать \"блок\" вокруг вашего комментария в исходном коде. Дополнительные символы звездочки просто игнорируются.\n\nНапример:\n/**********************\n\nThis is the start of a method\n\n***********************/\nДля документации будет сохранен только текст \"This is the start of a method\"."
            }
          },
          "practice": {
            "1": {
              "type": "r_task",
              "text": "Однострочные комментарии создаются с помощью:",
              "questions": [
                "** символов в начале строки",
                "// символов в конце строки",
                "*/ симовлов в начале строки",
                "// символов в начале строки"
              ],
              "succes": ["// символов в начале строки"]
            },
            "2": {
              "type": "it_task",
              "text": "Оберните следующий текст многострочным комментарием.",
              "rows": [
                ["", " здесь находится"],
                ["    какой-то текст"],
                ["",""]
              ],
              "paste": [
                1,3
              ],
              "succes": [
                "/*", "*/"
              ]
            },
            "3": {
              "type": "r_task",
              "text": "Вы можете добавить комментарий документации с помощью:",
              "questions": [
                "/* и */ для заключения строки",
                "// и */ для заключения строки",
                "/** и */ для заключения строки",
                "// символов в начале строки"
              ],
              "succes": ["/** и */ для заключения строки"]
            }
          }
        },
        "4": {
          "id": "4",
          "name": "Переменные",
          "theory": {
            "1": {
              "name": "Переменные",
              "text": "Переменные хранят данные для обработки.\nПеременным задается имя (или идентификатор), например area, age, height, и т.п. Имя уникально идентифицирует каждую переменную, присваивая значение переменной и получая хранящееся в переменной значение.\n\nПеременные имеют тип. Несколько примеров:\n\n- int: для целых чисел, таких как 123 и -456\n- double: для чисел с плавающей точкой или действительных чисел с опциональной десятичной точкой и дробной частью в фиксированной или научной нотации, такой как 3.1416, -55.66.\n- String: для текста, типа \"Hello\" или \"Good Morning!\". Текстовые строки заключаются внутри двойных кавычек.\n\nВы можете объявить переменную типа и присвоить ей значение. Пример:\n\nString name = \"David\";\n\nТаким образом создается переменная с именем name типа String, и ей присваивается значение \"David\".\nВажно отметить, что переменная ассоциируется с типом, и может только хранить значения данного типа. Например, переменная int может хранить целочисленные значения, такие как 123; но не может хранить действительные числа, такие как 12.34, или текст, например \"Hello\"."
            },
            "2": {
              "name": "Объявление переменных",
              "text": "Примеры объявления переменных:\n\nclass MyClass {\n  public static void main(String[ ] args) {\n   String name =\"David\";\n   int age = 42;\n   double score = 15.9;\n   char group = 'Z';\n   }\n}\n\nchar значит character(символ) и хранит один символ.\n\nДругим типом является boolean тип, который имеет только два возможных значения: true(истина) и false(ложь).\nЭтот тип данных используется для решения простых условий истинно/ложно.\nНапример:\n\nboolean online = true;\n\nВы можете использовать разделение запятыми в списке для объявления более одной переменной указанного типа. Например: int a = 42, b = 11;"
            }
          },
          "practice": {
            "1": {
              "type": "r_task",
              "text": "Какой тип переменной вы будете использовать для названия города?",
              "questions": [
                "double",
                "string",
                "int",
                "char"
              ],
              "succes": ["string"]
            },
            "2": {
              "type": "dd_task",
              "text": "Перетащите из варианто, указанных ниже, чтобы получить рабочую Java программу.",
              "questions": [
                "class",
                "double",
                "int",
                "void",
                "true",
                "String"
              ],
              "rows": [
                [" "],
                ["class MyClass"],
                ["    public static void main(String[] args) {"],
                [" "],
                ["    "," name = \"Сергей\";"],
                [" "],
                ["    "," age = 18;"],
                [" "],
                ["    "," height = 175.55;"],
                ["    }"],
                ["}"]
              ],
              "paste": [
                5,7,9
              ],
              "succes": [
                "String",
                "int",
                "double"
              ]
            }
          }
        },
        "5": {
          "id": "5",
          "name": "Типы данных",
          "theory": {
            "1": {
              "name": "Переменные",
              "text": "Переменные хранят данные для обработки.\nПеременным задается имя (или идентификатор), например area, age, height, и т.п. Имя уникально идентифицирует каждую переменную, присваивая значение переменной и получая хранящееся в переменной значение.\n\nПеременные имеют тип. Несколько примеров:\n\n- int: для целых чисел, таких как 123 и -456\n- double: для чисел с плавающей точкой или действительных чисел с опциональной десятичной точкой и дробной частью в фиксированной или научной нотации, такой как 3.1416, -55.66.\n- String: для текста, типа \"Hello\" или \"Good Morning!\". Текстовые строки заключаются внутри двойных кавычек.\n\nВы можете объявить переменную типа и присвоить ей значение. Пример:\n\nString name = \"David\";\n\nТаким образом создается переменная с именем name типа String, и ей присваивается значение \"David\".\nВажно отметить, что переменная ассоциируется с типом, и может только хранить значения данного типа. Например, переменная int может хранить целочисленные значения, такие как 123; но не может хранить действительные числа, такие как 12.34, или текст, например \"Hello\"."
            },
            "2": {
              "name": "Объявление переменных",
              "text": "Примеры объявления переменных:\n\nclass MyClass {\n  public static void main(String[ ] args) {\n   String name =\"David\";\n   int age = 42;\n   double score = 15.9;\n   char group = 'Z';\n   }\n}\n\nchar значит character(символ) и хранит один символ.\n\nДругим типом является boolean тип, который имеет только два возможных значения: true(истина) и false(ложь).\nЭтот тип данных используется для решения простых условий истинно/ложно.\nНапример:\n\nboolean online = true;\n\nВы можете использовать разделение запятыми в списке для объявления более одной переменной указанного типа. Например: int a = 42, b = 11;"
            }
          },
          "practice": {
            "1": {
              "type": "r_task",
              "text": "Какой тип переменной вы будете использовать для названия города?",
              "questions": [
                "double",
                "string",
                "int",
                "char"
              ],
              "succes": ["string"]
            },
            "2": {
              "type": "dd_task",
              "text": "Перетащите из варианто, указанных ниже, чтобы получить рабочую Java программу.",
              "questions": [
                "class",
                "double",
                "int",
                "void",
                "true",
                "String"
              ],
              "rows": [
                [" "],
                ["class MyClass"],
                ["    public static void main(String[] args) {"],
                [" "],
                ["    "," name = \"Сергей\";"],
                [" "],
                ["    "," age = 18;"],
                [" "],
                ["    "," height = 175.55;"],
                ["    }"],
                ["}"]
              ],
              "paste": [
                5,7,9
              ],
              "succes": [
                "String",
                "int",
                "double"
              ]
            }
          }
        },
        "6": {
          "id": "6",
          "name": "Примитивные операторы языка",
          "theory": {
            "1": {
              "name": "Математические операторы",
              "text": "Java обеспечивает богатым набором операторов для использования при манипулированиями переменными. Значение, используемое на другой стороне оператора называется операндом.\nНапример, в выражении ниже, числа 6 и 3 являются операндами оператора плюс:\n\nint x = 6 + 3;\n\nАрифметические операторы Java:\n+ сложение\n- вычитание\n* умножение\n/ деление\n% деление по модулю\nАрифметические операторы используются в математических выражениях таким же образом, как они используются в алгебраических уравнениях."
            },
            "2": {
              "name": "Математические операторы. Продолжение.",
              "text": "Оператор + складывает вместе два значения, например две константы, константу и переменную, или переменную и переменную. Несколько примеров сложения:\nint sum1 = 50 + 10;\nint sum2 = sum1 + 66;\nint sum3 = sum2 + sum2;\nОператор - вычитает одно значение из другого.\nint sum1 = 1000 - 10;\nint sum2 = sum1 - 5;\nint sum3 = sum1 - sum2;\nКак и в алгебре, вы можете использовать обе операции в одной строке. Например: int val = 10 + 5 - 2;\nОператор * перемножает два значения.\nint sum1 = 1000 * 2;\nint sum2 = sum1 * 10;\nint sum3 = sum1 * sum2;\nОператор / делит одно значение на другое.\nint sum1 = 1000 / 5;\nint sum2 = sum1 / 2;\nint sum3 = sum1 / sum2;"
            },
            "3": {
              "name": "Деление по модулю",
              "text": "Математическая операция деления по модулю (или остаток) выполняет целочисленное деление одного значения на другое и возвращает остаток от деления.\nОператором операции деления по модулю является символ процента (%).\nПример:\nint value = 23;\nint res = value % 6; // res is 5\nДеление 23 на 6 возвращает частное равное 3, с остатком равным 5. Таким образом, значение 5 присваивается переменной res."
            }
          },
          "practice": {
            "1": {
              "type": "it_task",
              "text": "Заполните пустые места, чтобы объявить целочисленную переменную и присвойте ей значение равное 5.",
              "rows": [
                ["int number = ",";"]
              ],
              "paste": [
                1
              ],
              "succes": [
                "5"
              ]
            },
            "2": {
              "type": "it_task",
              "text": "Заполните пустые места, чтобы вывести сумму двух переменных.",
              "rows": [
                ["int x = 2; int y = 4;"],
                ["int result = x "," y;"],
                ["System.ot.println(",");"]
              ],
              "paste": [
                2,3
              ],
              "succes": [
                "+",
                "result"
              ]
            },
            "3": {
              "type": "r_task",
              "text": "Какое значение будет в переменной result?\nint x = 8;\nint y = 5;\nint result = x % y;",
              "questions": [
                "1",
                "2",
                "3",
                "0"
              ],
              "succes": ["3"]
            }
          }
        },
        "7": {
          "id": "7",
          "name": "Считывание пользовательского ввода",
          "theory": {
            "1": {
              "name": "Считывание пользовательского ввода",
              "text": "В то время как Java предоставляет много различных методов для считывания пользовательского ввода, объект Scanner является наиболее распространенным, и возможно наиболее легким для применения. Импортируйте класс Scanner для использования объекта Scanner, как отображено далее:\n\nimport java.util.Scanner;\n\nЧтобы использовать класс Scanner, создайте экземпляр класса с помощью следующего синтаксиса:\n\nScanner myVar = new Scanner(System.in);\n\nТеперь вы можете считывать различные виды типов данных, которые вводит пользователь.\nВот несколько методов, которые доступны в классе Scanner:\nСчитать байт - nextByte()\nСчитать число типа int - nextInt()\nСчитать число типа double - nextDouble()\nСчитать число булевого типа - nextBoolean()\nСчитать целую строку - nextLine()\nСчитать слово - next()\n\nПример программы, используемой для считывания пользовательского ввода:\n\nimport java.util.Scanner;\n\nclass MyClass {\npublic static void main(String[ ] args) {\nScanner myVar = new Scanner(System.in);\nSystem.out.println(myVar.nextLine());\n   }\n}\nПрограмма будет ждать, пока пользователь введет что-нибудь, а затем выведет это на экран.\nВозможно, код покажется вам сложным, но вы поймете все в последующих уроках."
            }
          },
          "practice": {
            "1": {
              "type": "dd_task",
              "text": "Перетащите из вариантов, указанных ниже, чтобы считать пользовательский ввод.",
              "questions": [
                "input",
                "Scanner",
                "nextLine",
                "nextGet",
                "getLine"
              ],
              "rows": [
                [" "],
                ["import java.util.Scanner;"],
                ["class Test {"],
                ["    public static void main(String[] args) {"],
                ["    "," scanner = new Scanner(System.in);"],
                ["    String st = scanner.","();"],
                ["    }"],
                ["}"]
              ],
              "paste": [
                5,6
              ],
              "succes": [
                "Scanner",
                "nextLine"
              ]
            }
          }
        }
      }
    },
    "2": {
      "name": "Условные операторы и циклы",
      "sub_theme": {
        "1": {
          "id": "1",
          "name": "Условные операторы",
          "theory": {
            "1": {
              "name": "Выполнение решения",
              "text": "Условные операторы используются для выполнения различных действий, основанных на различных условиях.\n\nВыражение if является одним из наиболее часто используемых выражений.\nЕсли выражение условного оператора if является истинным, то будет выполнен блок кода внутри выражения if. Если выражение окажется ложным, то будет выполнен код, находящийся сразу после конца выражения if (после закрывающей фигурной скобки).\nСинтаксис:\nif (condition) {\n//Executes when the condition is true\n}\nЛюбой из следующих операторов сравнения может быть использован для формирования условия:\n< меньше чем\n> больше чем\n!= не равно\n== равно\n<= меньше, либо равно\n>= больше, либо равно\n\nНапример:\nint x = 7;\nif(x < 42) {\nSystem.out.println(\"Hi\");\n}\nНе забывайте, что использовать два знака равно (==) необходимо для проверки на равенство, а одиночный знак равенства является оператором присваивания."
            },
            "2": {
              "name": "Операторы if ... else",
              "text": "После оператора if может следовать опциональный оператор else, который выполняется, когда условие оказывается ложным.\n\nНапример:\nint age = 30;\n\nif (age < 16) {\nSystem.out.println(\"Too Young\");\n} else {\nSystem.out.println(\"Welcome!\");\n}\n//Outputs \"Welcome\"\nТак как переменная age равна 30, то условие if оказывается ложным и выполняется оператор else."
            },
            "3": {
              "name": "Вложенные операторы if",
              "text": "Вы можете использовать один оператор if-else внутри другого оператора if или else.\n\nНапример:\nint age = 25;\nif(age > 0) {\nif(age > 16) {\nSystem.out.println(\"Welcome!\");\n} else {\nSystem.out.println(\"Too Young\");\n}\n} else {\nSystem.out.println(\"Error\");\n}\n//Outputs \"Welcome!\"\nВы можете вкладывать столько операторов if-else сколько вам необходимо."
            },
            "4": {
              "name": "Оператор else if",
              "text": "Вместо использования вложенных операторов if-else, вы можете использовать оператор else if для проверки множества условий.\n\nНапример:\nint age = 25;\n\nif(age <= 0) {\nSystem.out.println(\"Error\");\n} else if(age <= 16) {\nSystem.out.println(\"Too Young\");\n} else if(age < 100) {\nSystem.out.println(\"Welcome!\");\n} else {\nSystem.out.println(\"Really?\");\n}\n//Outputs \"Welcome!\"\nКод проверит условие, и если оно будет истинно, то выполнится условие внутри блока.\nВы можете включать столько операторов else if, сколько вам необходимо. "
            }
          },
          "practice": {
            "1": {
              "type": "it_task",
              "text": "Заполните пустые поля, чтобы вывести \"Привет!\"",
              "rows": [
                ["int x = 5;"],
                [" ", "(x == 5) {"],
                ["    System.","println(\"Привет!\");"],
                ["}"]
              ],
              "paste": [
                2,3
              ],
              "succes": [
                "if",
                "out"
              ]
            },
            "2": {
              "type": "it_task",
              "text": "Заполните пустые поля, чтобы вывести наибольшее число.",
              "rows": [
                ["int x = 10; y = 5;"],
                ["", "(x > y) {"],
                ["    System.out.println(",");"],
                ["} "," {"],
                ["    System.out.println(y);"],
                ["}"]
              ],
              "paste": [
                2,3,4
              ],
              "succes": [
                "if",
                "x",
                "else"
              ]
            },
            "3": {
              "type": "it_task",
              "text": "Заполните пустые поля, во вложенном операторе if, чтобы вывести \"Внутри вложенного if\"",
              "rows": [
                ["int x = 37;"],
                ["if (x > 22) {"],
                ["    ","(x > 31) {"],
                ["         System.",".println(\"Внутри вложенного if\");"],
                ["    }"],
                ["}"]
              ],
              "paste": [
                3,4
              ],
              "succes": [
                "if",
                "out"
              ]
            },
            "4": {
              "type": "r_task",
              "text": "Сколько операторов else if может содержать оператор if??",
              "questions": [
                "один",
                "не больше двух",
                "сколько угодно",
                "ни одного"
              ],
              "succes": ["сколько угодно"]
            }
          }
        },
        "2": {
          "id": "2",
          "name": "Логические операторы",
          "theory": {
            "1": {
              "name": "Оператор &&",
              "text": "Логические операторы используются для комбинирования множества условий.\n\nСкажем, вы хотели бы, чтобы ваша программа выводила \"Welcome!\" только когда переменная age больше 18 и переменная money больше 500.\n\nОдним способом выполнения этого является использование вложенных операторов if:\nif (age > 18) {\nif (money > 500) {\nSystem.out.println(\"Welcome!\");\n}\n}\nОднако, использование логического оператора И (&&) является способом лучше:\nif (age > 18 && money > 500) {\nSystem.out.println(\"Welcome!\");\n}\nЕсли все операнды оператора И истинны, то условие будет истинным."
            },
            "2": {
              "name": "Операторы || и !",
              "text": "Оператор ИЛИ (||) проверяет, истинно ли какое-нибудь из условий.\nУсловие будет истинным, если любой из операндов будет истинным.\n\nНапример:\nint age = 25;\nint money = 100;\n\nif (age > 18 || money > 500) {\nSystem.out.println(\"Welcome!\");\n}\n//Outputs \"Welcome!\"\nВышеуказанный код выведет \"Welcome!\", если значение переменной age больше 18 или если значение переменной money больше 500.\nЛогический оператор НЕ (!) используется для установки противоположного логического состояния его операнда. Если условие верно, то логический оператор НЕ сделает его ложным.\nПример:\nint age = 25;\nif(!(age > 18)) {\nSystem.out.println(\"Too Young\");\n} else {\nSystem.out.println(\"Welcome\");\n}\n//Outputs \"Welcome\"\n!(age > 18) читается, как \"если age НЕ больше чем 18\"."
            }
          },
          "practice": {
            "1": {
              "type": "it_task",
              "text": "Заполните пустые места, чтобы выполнялось первое и второе условия.",
              "rows": [
                ["int age = 23;"],
                ["int money = 4000;"],
                ["if (age > 21 "," money > 500) {"],
                ["        System.out.println(\"Условия выполняются!\")"],
                ["}"]
              ],
              "paste": [
                3
              ],
              "succes": [
                "&&"
              ]
            },
            "2": {
              "type": "r_task",
              "text": "Что выведет следующий код?\n\nint a = 11; int b = 12; int c = 40;\nif (a > 100 || b > 3) {\n    System.ot.println(a);\n} else {\n    System.ot.println(c);\n}",
              "questions": [
                "40",
                "100",
                "12",
                "11"
              ],
              "succes": ["11"]
            }
          }
        },
        "3": {
          "id": "3",
          "name": "Оператор switch",
          "theory": {
            "1": {
              "name": "Оператор switch",
              "text": "Оператор switch проверяет переменную на равенство списку значений. Каждое значение называется case(случаем), и переменная оператора switch проверяется с каждым случаем.\nСинтаксис:\n\nswitch (expression) {\ncase value1 :\n//Statements\nbreak; //optional\ncase value2 :\n//Statements\nbreak; //optional\n//You can have any number of case statements.\ndefault : //Optional\n//Statements\n}\n- Если переменная оператора switch равна case, то выражения этого case будут выполняться до достижения оператора break.\n- Когда достигается оператор break, оператор switch завершается, поток управления переходит на следующую строку после оператора switch.\n- Не каждый case должен содержать оператор break. Если не встретился оператор break, то поток управления пройдет через несколько операторов case, пока не будет достигнут оператор break.\n\nВ примере ниже проверяется переменная day на соответствие с набором значений и выводится соответствующее сообщение.\n\nint day = 3;\n\nswitch(day) {\ncase 1:\nSystem.out.println(\"Monday\");\nbreak;\ncase 2:\nSystem.out.println(\"Tuesday\");\nbreak;\ncase 3:\nSystem.out.println(\"Wednesday\");\nbreak;\n}\n// Outputs \"Wednesday\"\nВы можете иметь любое количество операторов case внутри switch. После каждого оператора case следует значение для сравнения и двоеточие."
            },
            "2": {
              "name": "Оператор default",
              "text": "Выражение switch может иметь опциональный оператор default.\nОператор default может использоваться для выполнения задания, когда нет соответствий ни с одним из условий.\n\nНапример:\n\nint day = 3;\n\nswitch(day) {\n case 6:\n   System.out.println(\"Saturday\");\n   break;\n  case 7:\nSystem.out.println(\"Sunday\");\n  break;\ndefault:\nSystem.out.println(\"Weekday\");\n}\n// Outputs \"Weekday\"\nОператор break не нужен в случае default, потому что он всегда является последним оператором в выражении switch."
            }
          },
          "practice": {
            "1": {
              "type": "it_task",
              "text": "Заполните пустые места, чтобы проверить значение переменной используя оператор switch.",
              "rows": [
                ["int x = 100;"],
                ["", "(x) {"],
                ["case 10:"],
                ["   System.out.println(\"A\")"],
                ["   break;"],
                ["", " 20:"],
                ["   System.out.println(\"B\")"],
                ["   break;"],
                ["}"]
              ],
              "paste": [
                2,6
              ],
              "succes": [
                "switch",
                "case"
              ]
            },
            "2": {
              "type": "r_task",
              "text": "Что выведет следующий код?\n\nint a = 11; int b = 12; int c = 40;\nswitch(a) {\n case 40:\n    System.ot.println(b);\n    break;\n default:\n    System.ot.println(c);\n}",
              "questions": [
                "12",
                "11",
                "40",
                "23"
              ],
              "succes": ["40"]
            }
          }
        },
        "4": {
          "id": "4",
          "name": "Цикл for",
          "theory": {
            "1": {
              "name": "Цикл for",
              "text": "Еще одной цикличной структурой является цикл for. Цикл for позволяет вам эффективно создавать циклы, которые должны быть запущены определенное количестов раз.\nСинтаксис:\n\nfor (initialization; condition; increment/decrement) {\n statement(s)\n}\n\nInitialization(Инициализация): Выражение выполняется только один раз в начале цикла\nCondition(Условие): Выполняется при каждой итерации цикла. Цикл выполняет выражение повторно, пока условие не будет ложным.\nIncrement/Decrement(Инкремент/Декремент): Выполняется после каждой итерации цикла.\n\nСледующий пример выводит числа от 1 до 5.\n\nfor(int x = 1; x <=5; x++) {\n  System.out.println(x);\n}\n\nПеременная x инициализируется значением 1, и повторно выводит значение переменной x, пока условие x<=5 не станет ложным. При каждой итерации выполняется выражение x++, инкрементирующее x на единицу.\n\nОбратите внимание в синтаксисе на точки с запятыми (;) после инициализации и условия. У вас может быть любой тип условия и любой тип инкремента в цикле for.\n\nВ примере ниже выводятся только четные числа, лежащие от 0 до 10: \n\nfor(int x=0; x<=10; x=x+2) {\n System.out.println(x);\n}"
            }
          },
          "practice": {
            "1": {
              "type": "dd_task",
              "text": "Перетащите из вариантов указанных ниже, чтобы вывести \"Отлично\" 10 раз.",
              "questions": [
                "10",
                "for",
                "Отлично",
                "i--",
                "i"
              ],
              "rows": [
                [" "],
                ["for (int i = 0; i < ", ";i++) {"],
                [" "],
                ["    System.out.println(\"","\");"],
                [" "],
                ["}"]
              ],
              "paste": [
                2,4
              ],
              "succes": [
                "10",
                "Отлично"
              ]
            }
          }
        },
        "5": {
          "id": "5",
          "name": "Циклы while и do ... while",
          "theory": {
            "1": {
              "name": "Цикл while",
              "text": "Цикл (loop) позволяет вам повторно выполнять выражение, или группу выражений.\n\nВыражение цикла while повторно выполняется, пока заданное условие истинно.\n\nПример:\n\nint x = 3;\n\nwhile(x > 0) {\n  System.out.println(x);\n  x--;\n}\n/*\nOutputs\n3\n2\n1\n*/\nЦикл while проверяет условие x > 0. Если оно истинно, то выполняются выражения в теле цикла. Затем выражение проверяется снова и повторяется цикл.\nОбратите внимание на выражение x--. Оно декрементирует переменную x при каждом запуске цикла, и останавливает цикл, когда x равно 0.\nБез этого выражения цикл будет запускаться без остановки.\nОбратите внимание на выражение x--. Оно декрементирует переменную x при каждом запуске цикла, и останавливает цикл, когда x равно 0.\nБез этого выражения цикл будет запускаться без остановки.\n\nint x = 6;\n\nwhile( x < 10 )\n{\n System.out.println(x);\n x++;\n}\nSystem.out.println(\"Цикл закончен\");\n\n/*\n6\n7\n8\n9\nЦикл закончен\n*/"
            },
            "2": {
              "name": "Цикл do ... while",
              "text": "Цикл do...while похож на цикл while, за исключением того, что цикл do...while гарантированно запустится по меньшей мере один раз.\n\nПример:\n\nint x = 1;\n\ndo {\n System.out.println(x);\nx++;\n} while(x < 5);\n\n/*\n1\n2\n3\n4\n*/\nОбратите внимание, что условие появляется в конце цикла, так что выражения цикла выполняются один раз до проверки условия.\n\nДаже если условие ложно, коды выполнится один раз. Пример:\n\nint x = 1;\ndo {\n System.out.println(x);\n x++;\n} while(x < 0);\n\n//Outputs 1\nОбратите внимание, что в do...while циклах while - это просто условие и не оно имеет тела."
            },
            "3": {
              "name": "Операторы управления циклами",
              "text": "Операторы break и continue изменяют ход выполнения цикла.\nОператор break заканчивает цикл и переводит выполнение к выражению, следующему за циклом.\n\nПример:\n\nint x = 1;\n\nwhile(x > 0) {\n System.out.println(x);\nif(x == 4) {\n break;\n}\nx++;\n}\n\n/* Outputs\n1\n2\n3\n4\n*/\nОператор continue заставляет цикл пропустить остаток его тела и затем немедленно протестировать его условие до переитерации. Другими словами, он заставляет цикл перейти к следующей итерации.\n\nПример:\n\nfor(int x=10; x<=40; x=x+10) {\n if(x == 30) {\n  continue;\n}\n System.out.println(x);\n}\n/* Outputs\n10\n20\n40\n*/\nКак видите, в вышеуказанном коде пропускается значение, равное 30, из-за оператора continue."
            }
          },
          "practice": {
            "1": {
              "type": "pl_task",
              "questions": [
                "x++; }",
                "while (x < 50) {",
                "int x = 25;",
                "   System.out.println(\"Цикл while\");"
              ],
              "text": "Переставьте код местами, чтобы получить рабочий конечный цикл, котоырй выводит текст на экран.",
              "succes": [
                "int x = 25;",
                "while (x < 50) {",
                "   System.out.println(\"Цикл while\");",
                "x++; }"
              ]
            },
            "2": {
              "type": "r_task",
              "text": "Чем отличается цикл do ... while от while?",
              "questions": [
                "Цикл while запускает код до проверки условия.",
                "Цикл do ... while проверяет условие до запуска кода",
                "Цикл do ... while запускает ваш код по меньшей мере 1 раз",
                "Нет правильного ответа"
              ],
              "succes": ["Цикл do ... while запускает ваш код по меньшей мере 1 раз"]
            },
            "3": {
              "type": "r_task",
              "text": "Какой оператор используется для прерывания циклов?",
              "questions": [
                "end",
                "break",
                "continue",
                "finish"
              ],
              "succes": ["break"]
            }
          }
        }
      }
    },
    "3": {
      "name": "Массивы",
      "sub_theme": {
        "1": {
          "id": "1",
          "name": "Одномерные массивы",
          "theory": {
            "1": {
              "name": "Массивы",
              "text": "Массив является коллекцией переменных одного типа.\nЕсли вам необходимо хранить список значений, например чисел, то вы можете хранить их в массиве, вместо объявления отдельных переменных для каждого числа.\n\nЧтобы объявить массив, вам необходимо определить тип элемента с квадратными скобками.\n\nНапример, чтобы объявить целочисленный массив:\nint[ ] arr;\nИмя массива arr. Типом содержащихся в нем элементов является int.\n\nТеперь вам необходимо определить длину массива, или количество элементов, которые он будет хранить. Чтобы это сделать, используйте ключевое слово new.\nint[ ] arr = new int[5];\nВ вышеуказанном коде объявлен массив 5 целых чисел.\nВ массиве все элементы упорядочены и каждый имеет определенную и постоянную позицию, которая называется индексом.\n\nЧтобы обратиться к элементу массива, введите имя массива с его индексом в квадратных скобках.\nПример:\narr[2] = 42;\nТаким образом присваивается значение 42 элементу, имеющему индекс 2.\nОбратите внимание, что элементы массива начинаются с нулевого индекса, что означает, что индексом первого элемента является 0, а не 1. Так что, максимальный индекс массива int[5] это 4.\n Java имеет сокращенный способ инстанциирования массивов примитивных типов и строк.\nЕсли вы уже знаете, какие значения использовать в массиве, то вы можете использовать массив литералов.\n\nПример массива литералов:\nString[ ] myNames = { \"A\", \"B\", \"C\", \"D\"};\nSystem.out.println(myNames[2]);\n\n// Outputs \"C\"\nРазместите значения в списке разделенном запятыми, закрытым в фигурные скобки.\nВышеуказанный код автоматически инициализирует массив, содержащий 4 элемента и сохраняет полученные значения.\nИногда вы можете увидеть квадратные скобки, размещенные после имени массива, что также работает, но предпочитаемым способом является размещение скобок после типа данных массива."
            }
          },
          "practice": {
            "1": {
              "type": "it_task",
              "text": "Заполните пустые места, чтобы посчитать сумму элементов массива myArr используя цикл for и вывусти ее на экран. myArray - это массив переменных типа int, содержащих 4 числа.",
              "rows": [
                ["int x = 100;"],
                ["", "(x) {"],
                ["case 10:"],
                ["   System.out.println(\"A\")"],
                ["   break;"],
                ["", " 20:"],
                ["   System.out.println(\"B\")"],
                ["   break;"],
                ["}"]
              ],
              "paste": [
                2,6
              ],
              "succes": [
                "switch",
                "case"
              ]
            }
          }
        },
        "2": {
          "id": "2",
          "name": "Многомерные массивы",
          "theory": {
            "1": {
              "name": "Добро пожаловать в Java",
              "text": "Многомерными массивами являются массивы, которые содержат другие массивы. Двухмерный массив является наиболее часто применяемым многомерным массивом.\n\nДля создания многомерного массива разместите каждый массив внутри своей пары квадратных скобок. Пример двухмерного массива:\nint[ ][ ] sample = { {1, 2, 3}, {4, 5, 6} };\nТаким образом объявляется массив с двумя массивами в элементе. Для получения доступа к элементу двухмерного массива необходимо предоставить два индекса, один для массива, а другой для элемента этого массива.\n\nСледующий пример получает доступ к первому элементу второго массива.\nint x = sample[1][0];\nSystem.out.println(x);\n\n// Outputs 4\nДва индекса массива называются индексом строки и индексом столбца.\n\nВы можете получить и установить элементы многомерного массива используя такую же пару квадратных скобок.\nint[ ][ ] myArr = { {1, 2, 3}, {4}, {5, 6, 7} };\nmyArr[0][2] = 42;\nint x = myArr[1][0]; // 4\nВ вышеуказанном двухмерном массиве содержится три массива. Первый массив имеет три элемента, второй имеет один элемент, а третий имеет три элемента.\nВ Java, вы не ограничены использованием только двухмерных массивов. Массивы могут быть вложены внутри массивов на столько уровней, сколько необходимо вашей программе. Чтобы объявить массив с более чем двумя измерениями, вам необходимо добавить столько пар пустых скобок, сколько вам нужно. Однако ими сложно управлять.\nПомните, что все члены массива должны быть одного типа."
            }
          },
          "practice": {
            "1": {
              "type": "r_task",
              "text": "Что выведет следующий код?\nint array[] = {{5,8,9,3}, {7,54,12,35}};\nSystem.out.println(array[1][3]);",
              "questions": [
                "9",
                "54",
                "35",
                "8"
              ],
              "succes": ["35"]
            }
          }
        }
      }
    },
    "4": {
      "name": "Классы и объекты",
      "sub_theme": {
        "1": {
          "id": "1",
          "name": "Объектно-ориентированное программирование",
          "theory": {
            "1": {
              "name": "Что такое ООП?",
              "text": "Java использует Объектно-Ориентированное Программирование (ООП), стиль программирования, который предназначен, чтобы сделать мышление о программировании ближе к мышлению о реальном мире. В ООП, каждый объект является независимой единицей с уникальным идентификатором, также, как и объекты в реальном мире.\nНапример, яблоко является объектом; также и кружка. Каждый имеет свой уникальный идентификатор. Может быть две кружки, которые будут очень похожи друг на друга, но они все равно разные, уникальные объекты.\nОбъекты также имеют характеристики, которые используются для их описания.\n\nНапример, машина может быть красной или синей, кружка может быть полной или пустой, и так далее. Эти характеристики также называются атрибутами. Атрибут описывает текущее состояние объекта.\n\nВ реальном мире каждый объект ведет себя по-своему. Машина движется, телефон звонит и так далее. То же самое касается и объектов: поведение специфично объекту типу объекта.\nВ общем, в объектно-ориентированном программировании, каждый объект имеет три измерения: идентификатор, атрибуты, и поведение. Атрибуты описывают текущее состояние объекта, и что объект способен делать демонстрируется через поведение объекта.\n\nКласс описывает каким будет объект, но отделен от самого объекта.\nДругими словами, классы можно назвать проектами, описаниями, или определениями для объекта. Вы можете использовать один и тот же класс в качестве проекта для создания множества объектов. Первым шагом является определение класса, что затем становится проектом для создания объекта.\n\nКаждый класс имеет имя, которое используется для определения атрибутов и поведения."
            }
          },
          "practice": {
            "1": {
              "type": "cb_task",
              "text": "Класс определяет ...(выберите все правильные ответы).",
              "questions": [
                "значения",
                "поведение",
                "атрибуты",
                "ссылки"
              ],
              "succes": [
                "поведение",
                "атрибуты"
              ]
            }
          }
        },
        "2": {
          "id": "2",
          "name": "Методы",
          "theory": {
            "1": {
              "name": "Методы",
              "text": "Методы определяют поведение. Метод является коллекцией выражений, сгруппированных вместе для выполнения действия. System.out.println() является примером метода.\n\nВы можете определить свои собственные методы для выполнения желаемых действий.\n\nДавайте рассмотрим следующий код:\nclass MyClass {\n\nstatic void sayHello() {\nSystem.out.println(\"Hello World!\");\n}\n\npublic static void main(String[ ] args) {\nsayHello();\n}\n}\n// Outputs \"Hello World!\"\nВ вышеуказанном коде объявлен метод \"sayHello\", который печатает текст, и вызывается в main.\nЧтобы вызвать метод, введите его имя и пару круглых скобок."
            },
            "2": {
              "name": "Вызов методов",
              "text": "Вы можете вызвать метод любое количество раз. При запуске метода код перескакивает в место, где метод был определен, выполняет код внутри него, а затем возвращается обратно и выполняет последующие строки.\nclass MyClass {\n\nstatic void sayHello() {\nSystem.out.println(\"Hello World!\");\n}\n\npublic static void main(String[ ] args) {\nsayHello();\nsayHello();\nsayHello();\n}\n}\n\n// Hello World!\n// Hello World!\n// Hello World!\nВ случаях, подобных случаям выше, где одно и то же повторяется снова и снова, вы можете достичь такого же результата, используя циклы (while или for)."
            },
            "3": {
              "name": "Параметры методов",
              "text": "Вы также можете создать метод, который принимает некоторую информацию, называемую параметрами, при его вызове. Параметры методов необходимо указывать внутри круглых скобок.\n\nНапример, мы можем модифицировать наш метод sayHello(), чтобы он принимал параметр String.\nВы также можете создать метод, который принимает некоторую информацию, называемую параметрами, при его вызове. Параметры методов необходимо указывать внутри круглых скобок.\n\nНапример, мы можем модифицировать наш метод sayHello(), чтобы он принимал параметр String.\n\nclass MyClass {\n\nstatic void sayHello(String name) {\nSystem.out.println(\"Hello \" + name);\n}\n\npublic static void main(String[ ] args) {\nsayHello(\"David\");\nsayHello(\"Amy\");\n}\n\n}\n// Hello David\n// Hello Amy\n\nВышеуказанный метод принимает строку с именем name в качестве параметра, который используется в теле метода. Затем, при вызове метода, мы передаем значение параметра в скобки.\n\nМетод может иметь множество параметров, разделенных запятыми.\n\nПреимуществом использования методов вместо одиночных выражений является следующее:\n- повторное использование кода: Вы можете написать метод один раз, а использовать его множество раз, без необходимости переписывания кода при каждом использовании.\n- параметры: Основываясь на переданных методах, методы могут выполнять различные действия"
            },
            "4": {
              "name": "Возвращаемый тип. Часть 1.",
              "text": "Ключевое слово return может быть использовано в методах для возвращения значения.\n\nНапример, мы можем определить метод sum, который возвращает сумму его двух параметров.\nstatic int sum(int val1, int val2) {\nreturn val1 + val2;\n}\nОбратите внимание, что в описании метода мы указали возвращаемый тип до определения имени метода. Для нашего метода sum, типом является int, так как он принимает два параметра типа int и возвращает их сумму, которая также имеет тип int.\nТеперь, мы можем использовать метод в нашем main.\nclass MyClass {\n\nstatic int sum(int val1, int val2) {\nreturn val1 + val2;\n}\n\npublic static void main(String[ ] args) {\nint x = sum(2, 5);\nSystem.out.println(x);\n}\n}\n// Outputs \"7\"\nТ.к. метод возвращает значение, мы можем присвоить его переменной."
            },
            "5": {
              "name": "Возвращаемый тип. Часть 2.",
              "text": "Взгляните на тот же самый код из предыдущего урока с комментариями, чтобы лучше понять, как он работает:\n// returns an int value 5\nstatic int returnFive() {\nreturn 5;\n}\n\n// has a parameter\nstatic void sayHelloTo(String name) {\nSystem.out.println(\"Hello \" + name);\n}\n\n// simply prints\"Hello World!\"\nstatic void sayHello() {\nSystem.out.println(\"Hello World!\");\n}\nПолучив знания о возвращаемых типах и параметрах методов, давайте взглянем на определение метода main.\npublic static void main(String[ ] args)\nЭто определение указывает, что метод main принимает массив элементов типа String в качестве параметров, и не возвращает значение."
            },
            "6": {
              "name": "Возвращаемый тип. Часть 3.",
              "text": "Давайте создадим метод, принимающий два параметра типа int и возвращающий наибольший из них, затем вызовем его в main:\npublic static void main(String[ ] args) {\nint res = max(7, 42);\nSystem.out.println(res); //42\n}\n\nstatic int max(int a, int b) {\nif(a > b) {\nreturn a;\n}\nelse {\nreturn b;\n}\n}\nМетод может иметь один тип параметра (или параметров) и возвращать другой, отличающийся тип. Например, он может взять два double и вернуть int."
            }
          },
          "practice": {
            "1": {
              "type": "it_task",
              "text": "Заполните пустые места, чтобы вызвать метод 'hello' из main",
              "rows": [
                ["public static void main(String[] args) {"],
                ["    ",";"],
                ["}"],
                [" "],
                ["static void hello() {"],
                ["    System.out.println(\"Hello world!\""],
                ["}"]
              ],
              "paste": [
                2
              ],
              "succes": [
                "hello()"
              ]
            },
            "2": {
              "type": "r_task",
              "text": "Сколько раз можно вызвать метод?",
              "questions": [
                "1 раз",
                "2 раза",
                "3 раза",
                "Столько, сколько необходимо"
              ],
              "succes": ["Столько, сколько необходимо"]
            },
            "3": {
              "type": "r_task",
              "text": "Что выведет следующий код?\npublic static void main(String[] args) {\n    doSomething(4);\n}\nstatic void doSomething(int x) {\n    System.out.println(x*x);\n}",
              "questions": [
                "Произойдет ошибка компиляции",
                "4",
                "16",
                "0"
              ],
              "succes": ["16"]
            },
            "4": {
              "type": "r_task",
              "text": "Если вы не хотите, чтобы метод что-либо возвращал, то вам необходимо использовать улючевое слово:",
              "questions": [
                "static",
                "void",
                "empty",
                "main"
              ],
              "succes": ["void"]
            },
            "5": {
              "type": "it_task",
              "text": "Заполните пустые места, чтобы объявить переменную типа int и переайте ее в качестве параметра в метод test().",
              "rows": [
                ["public static void main(String[] args) {"],
                ["    "," x = 10;"],
                ["    test(",")"],
                ["}"],
                ["static void test(int x) {"],
                ["Sustem.out.println(x);"],
                ["}"]
              ],
              "paste": [
                1,2
              ],
              "succes": [
                "class",
                "main"
              ]
            },
            "6": {
              "type": "r_task",
              "text": "Что выведет следующий код?\npublic static void main(String[] args) {\n    int x = 10;\n    int y = myFunc(x);\n    System.out.println(y);\n}\npublic static int myFunc(int x) {\n    return x*3;\n}",
              "questions": [
                "0",
                "3",
                "10",
                "y"
              ],
              "succes": ["30"]
            }
          }
        },
        "3": {
          "id": "3",
          "name": "Создание классов и объектов",
          "theory": {
            "1": {
              "name": "Создание классов",
              "text": "Для создание классов используется специальное слово class. Ниже приведем код на котором создается класс:\nclass MyClass {\n//code\n}\nКласс имеет атрибуты и методы. Атрибуты являются переменными внутри класса.\n\nДавайте создадим класс Vehicle с соответствующими атрибутами и методами.\npublic class Vehicle {\nint maxSpeed;\nint wheels;\nString color;\ndouble fuelCapacity;\n\nvoid horn() {\nSystem.out.println(\"Beep!\");\n}\n}\nmaxSpeed, wheels, color, и fuelCapacity являются атрибутами нашего класса Vehicle, а horn() является единственным методом.\nВы можете определить столько атрибутов и методов, сколько вам необходимо."
            },
            "2": {
              "name": "Создание объектов",
              "text": "Давайте перейдем к нашему main и создадим новый объект нашего класса.\nMyClass.java\nclass MyClass {\npublic static void main(String[ ] args) {\nAnimal dog = new Animal();\ndog.bark();\n}\n}\n// Outputs \"Woof-Woof\"\nТеперь, dog является объектом типа Animal. Следовательно, мы можем вызвать его метод bark(), используя имя объекта и точку.\n\nТочка используется для получения доступа к атрибутам и методам объекта.\n\nТеперь, мы можем создать множество объектов нашего класса Vehicle, и использовать синтаксис с точкой, чтобы получить доступ к его атрибутам и методам.\n\nclass MyClass {\npublic static void main(String[ ] args) {\nVehicle v1 = new Vehicle();\nVehicle v2 = new Vehicle();\nv1.color = \"red\";\nv2.horn();\n}\n}"
            }
          },
          "practice": {
            "1": {
              "type": "dd_task",
              "text": "Перетащите из вариантов, указанных ниже, чтобы определить класс Person со следующими атрибутами: age типа int, height типа double, name типа string.",
              "questions": [
                "define",
                "attribute",
                "class",
                "int",
                "viod",
                "String",
                "double"
              ],
              "rows": [
                [" "],
                ["  ", " Person {"],
                [" "],
                ["  ", " age;"],
                [" "],
                ["  ", " height;"],
                [" "],
                ["  ", " name;"],
                ["}"]
              ],
              "paste": [
                2,4,6,8
              ],
              "succes": [
                "class",
                "int",
                "double",
                "String"
              ]
            },
            "2": {
              "type": "dd_task",
              "text": "Перетащите из вариантов, указанных ниже, чтобы создать объект класса А в классе В и вызовите его метод \"test\"",
              "questions": [
                "main",
                "test()",
                "new",
                "method",
                "class",
                "newObject"
              ],
              "rows": [
                [" "],
                ["public ", " A {"],
                [" "],
                ["    public void ", " {"],
                ["        System.out.println(\"Hello!\")"],
                ["    }"],
                ["}"],
                ["class B {"],
                [" "],
                ["    A obj = "," A();"],
                [" "],
                ["    obj.",";"],
                ["}"]
              ],
              "paste": [
                2,4,10,12
              ],
              "succes": [
                "class",
                "test()",
                "new",
                "test()"
              ]
            }
          }
        },
        "4": {
          "id": "4",
          "name": "Модификаторы доступа",
          "theory": {
            "1": {
              "name": "Модификаторы доступа",
              "text": "Теперь давайте обсудим ключевое слово public перед методом main.\npublic является модификатором доступа, что означает, что он используется для установки уровня доступа. Вы можете использовать модификаторы доступа для классов, атрибутов и методов.\n\nВ случае с классами, доступными модификаторами являются public или default, как описано ниже:\npublic: к классу может быть получен доступ любым другим классом.\ndefault: к классу может быть получен доступ только классами из одного пакета (package).\n\nСледующие варианты доступны для атрибутов и методов:\ndefault: атрибут или метод, объявленный без модификатора ограничения доступа, доступен для любого другого класса в том же пакете (package).\npublic: доступ может быть получен из любого класса.\nprotected: обеспечивает такой же доступ, как и модификатор default, с добавлением, что подкласс может получить доступ к protected методам и переменным суперкласса (О подклассах и суперклассах будет рассказано в последующих уроках).\nprivate: доступ может быть получен только изнутри этого объявленного класса.\n\n"
            }
          },
          "practice": {
            "1": {
              "type": "cb_task",
              "text": "Что из перечисленных вариантов является модификатором доступа?",
              "questions": [
                "protected",
                "public",
                "private",
                "hidden"
              ],
              "succes": [
                "public",
                "private"
              ]
            }
          }
        }
      }
    },
    "5": {
      "name": "Коллекции",
      "sub_theme": {
        "1": {
          "id": "1",
          "name": "Коллекции",
          "theory": {
            "1": {
              "name": "Collection",
              "text": "Java API предоставляет специальные классы для хранения и управления группами объектов. Одним из таких классов является ArrayList. Стандартные Java массивы имеют фиксированную длину, что означает, что после их создания они не могут быть расширены, или уменьшены.\n\nС другой стороны, классы ArrayList создаются с первоначальным размером, но если размер превышается, то коллекция автоматически увеличивается.\n\nКогда объекты удаляются, ArrayList может уменьшиться в размере. Обратите внимание, что класс ArrayList находится в пакете java.util, так что необходимо его импортировать до использования.\nСоздадим ArrayList.\nimport java.util.ArrayList;\n//...\nArrayList colors = new ArrayList();\nВы можете опционально определить емкость и тип объектов, которые будет содержать класс ArrayList:\nArrayList<String> colors = new ArrayList<String>(10);\nВ вышеуказанном коде определяется ArrayList переменных типа String с 10 в качестве его начального размера.\nArrayLists хранит объекты. Таким образом, указанный тип должен быть типом класса. Вы не можете передать, например тип int, в качестве типа объекта. Вместо этого, используйте специальные типы классов, которые соответствуют желаемому типу значения, например Integer для int, Double для double, и так далее.\nКласс ArrayList предоставляет множество полезных методов для управления его объектами.\n\nМетод add() добавляет новые объекты классу ArrayList. И наоборот, метод remove() удаляет объекты из класса ArrayList.\nК другим полезным методам относятся следующие:\n- contains(): Возвращает «верно», если список содержит указанный элемент\n- get(int индекс): Возвращает элемент на указанной позиции в списке\n- size(): Возвращает число элементов списка\n- clear(): Удаляет все элементы из списка\n\nОбратите внимание: Также как и с массивами, индексирование начинается с 0."
            }
          },
          "practice": {
            "1": {
              "type": "r_task",
              "text": "Что выведет следующий код?\n\nArrayList<Strng> list = new ArrayList<Strng>();\nlist.add('A');\nlist.add('B');\nlist.add('C');\nSystem.out.println(list.get(1));",
              "questions": [
                "A",
                "B",
                "C",
                "1"
              ],
              "succes": ["B"]
            }
          }
        }
      }
    },
    "6": {
      "name": "Работа с файлами",
      "sub_theme": {
        "1": {
          "id": "1",
          "name": "Работа с файлами. Чтение из файла",
          "theory": {
            "1": {
              "name": "Работа с файлами. Чтение из файла",
              "text": "Пакет java.io включает в себя класс File, который позволяет вам работать с файлами.\n\n    Чтобы начать, создайте объект File и укажите путь к файлу в конструкторе.\n\n    import java.io.File;\n    ...\n    File file = new File(\"C:\\\\data\\\\input-file.txt\");\n\n    С помощью метода exists(), вы можете определить, существует ли файл.\n\n    import java.io.File;\n\n    public class MyClass {\n    public static void main(String[ ] args) {\n    File x = new File(\"C:\\\\sololearn\\\\test.txt\");\n    if(x.exists()) {\n    System.out.println(x.getName() + \"exists!\");\n    }\n    else {\n    System.out.println(\"The file does not exist\");\n    }\n    }\n    }\n\n    Вышеуказанный код выводит сообщение о том, существует, или нет, файл, по указанному вами пути.\n\n    Метод getName() возвращает имя файла.\n    Обратите внимание, что мы использовали двойные обратные косые черты (слэши) в пути, потому что одинарные слэши будут опущены в строке пути к файлу.\n\n    Файлы полезны для хранения и получения информации, и существует множество способов чтения файлов.\n\n    Одним из простейших способов является использование класса Scanner из пакета java.util.\n\n    Конструктор класса Scanner может принимать объект File в качестве ввода.\n\n    Для чтения содержимого текстового файла, лежащего в \"C:\\\\sololearn\\\\test.txt\", нам необходимо создать объект File с соответствующим путем и передать его объекту Scanner.\n\n    try {\n    File x = new File(\"C:\\\\sololearn\\\\test.txt\");\n    Scanner sc = new Scanner(x);\n    }\n    catch (FileNotFoundException e) {\n\n    }\n\n    Мы окружили код блоком try/catch, потому что существует вероятность, что файл не будет существовать.\n\n    Класс Scanner наследуется от класса Iterator, так что он ведет себя похожим образом.\n\n    Мы можем использовать метод next() объекта Scanner для чтения содержимого файла.\n\n    try {\n    File x = new File(\"C:\\\\sololearn\\\\test.txt\");\n    Scanner sc = new Scanner(x);\n    while(sc.hasNext()) {\n    System.out.println(sc.next());\n    }\n    sc.close();\n    } catch (FileNotFoundException e) {\n    System.out.println(\"Error\");\n    }\n\n    Содержимое файла будет выводится слово за словом, потому что метод next() возвращает каждое слово отдельно.\n\n    Закрывать файл после завершения работы с ним всегда является хорошей практикой. Одним из способов этого является метод close().\n\n"
            },
            "2": {
              "name": "Создание и запись файлов",
              "text": "Formatter, другой полезный класс в пакете java.util, используется для создания содержимого и записи его в файлы.\n\n    Пример:\n    import java.util.Formatter;\n\n    public class MyClass {\n    public static void main(String[ ] args) {\n    try {\n    Formatter f = new Formatter(\"C:\\\\sololearn\\\\test.txt\");\n    } catch (Exception e) {\n    System.out.println(\"Error\");\n    }\n    }\n    }\n    Таким образом создается пустой файл по указанному пути. Если файл уже существует, то он будет переписан.\n    И опять, вам необходимо окружить код блоком try/catch, потому что операция может закончиться неудачей.\n\n    После того, как файл был создан, вы можете записать содержимое в него, используя метод format() объекта Formatter.\n\n    Пример:\n    import java.util.Formatter;\n\n    public class MyClass {\n    public static void main(String[ ] args) {\n    try {\n    Formatter f = new Formatter(\"C:\\\\sololearn\\\\test.txt\");\n    f.format(\"%s %s %s\", \"1\",\"John\", \"Smith \\r\\n\");\n    f.format(\"%s %s %s\", \"2\",\"Amy\", \"Brown\");\n    f.close();\n    } catch (Exception e) {\n    System.out.println(\"Error\");\n    }\n    }\n    }\n    Метод format() форматирует его параметры согласно с первым параметром.\n\n    %s означает строку и заменяется первым параметром после метода format. Второй %s заменяется следующим параметром и так далее. Значит, формат %s %s %s означает три строки, разделенные пробелами.\n\n    Обратите внимание: \\r\\n это символ новой строки в Windows.\n\n    Не забывайте закрывать файлы, после того, как вы закончили с ними работать!\n\n"
            }
          },
          "practice": {
            "1": {
              "type": "r_task",
              "text": "Какой класс может быть использован для чтения файлов?",
              "questions": [
                "Set",
                "ArrayList",
                "HashMap",
                "Scanner"
              ],
              "succes": ["Scanner"]
            },
            "2": {
              "type": "pl_task",
              "questions": [
                "f.close();",
                "f.format(\"%s\", \"world!\");",
                "Formatter f = new Formatter(\"my_text.txt\");",
                "f.format(\"%s\", \"Hello\");"
              ],
              "text": "Переставьте код местами, чтобы записать в файл \"Hello world!\"",
              "succes": [
                "Formatter f = new Formatter(\"my_text.txt\");",
                "f.format(\"%s\", \"Hello\");",
                "f.format(\"%s\", \"world!\");",
                "f.close();"
              ]
            }
          }
        }
      }
    }
  }
}